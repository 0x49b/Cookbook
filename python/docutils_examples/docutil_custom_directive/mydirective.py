from docutils import nodes
from docutils.parsers.rst import directives, Directive
from docutils.writers import html5_polyglot
from docutils.core import publish_string


class MyCustomDirective(Directive):
    required_arguments = 1
    optional_arguments = 0  # It will add up required+optional for maximum allowed args
    final_argument_whitespace = True  # True returns all args as single string; False->1 word 1 arg
    has_content = True  # Multi-line block after initial line?

    def run(self):
        self.assert_has_content()
        # On error, you can ``raise self.error('Error message.')``

        # You have access to all arguments and options
        # self.arguments
        # self.options
        print(self.arguments)  # the content following directive
        print(self.options)
        print(self.content)  # List with each line of the content (text on lines after initial directive call)

        # You can return one or more nodes that will be inserted at the
        # location where the directive was called. The output format
        # will depend on the translator/writer that is used after
        # the parser is done reading and calling all directives to generate
        # the node tree.
        comment_node = nodes.comment(text="Section generated by " + __file__)
        warning_node = nodes.warning()
        text_node = nodes.Text("Who dares call my custom directive!?")
        line_node = nodes.transition()
        # You could simply return the nodes as a list
        # return [comment_node, line_node, text_node]

        # But, if you want to wrap multiple nodes up in a section with
        # a special class name, create a section and put the nodes in it.
        # This will wrap them with a <div class="section"> w/ html5 writer
        section_node = nodes.section()
        section_node['classes'] = ['my-custom-css-class', 'another-style']
        section_node.append(comment_node)
        section_node.append(warning_node)
        section_node.append(text_node)
        section_node.append(line_node)

        return [section_node]


directives.register_directive('mydirective', MyCustomDirective)


if __name__ == '__main__':
    reStructuredText_source = """=====================
Custom directive test
=====================

Some text

.. mydirective:: MyArgument1 test test
   :option1: My value for option 1
   :option2: 42

  my directive's content block goes here
  multi line is ok

My directive should have run now.
"""

    # Since the directive was registered already, it should get used when
    # the parser runs when it encounters the ``.. mydirective::`` text.
    html_output = publish_string(source=reStructuredText_source,
                                 writer=html5_polyglot.Writer())
    
    #print(html_output.decode('utf8'))

